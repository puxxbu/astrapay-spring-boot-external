This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
src/
  main/
    java/
      com/
        astrapay/
          configuration/
            ExampleConfig.java
          controller/
            advice/
              GlobalExceptionHandler.java
            NoteController.java
          dto/
            request/
              CreateNoteRequestDto.java
            response/
              BaseResponse.java
              NoteDto.java
          entity/
            Note.java
          exception/
            NoteNotFoundException.java
          repository/
            NoteRepository.java
            NoteRepositoryImpl.java
          service/
            NoteService.java
          util/
            ResponseHelper.java
          SimpleNotesApplication.java
    resources/
      application.properties
  test/
    java/
      com/
        astrapay/
          controller/
            NoteControllerTest.java
          service/
            NoteServiceTest.java
.gitignore
pom.xml
postman.json
README.md

================================================================
Files
================================================================

================
File: src/main/java/com/astrapay/controller/advice/GlobalExceptionHandler.java
================
package com.astrapay.controller.advice;

import com.astrapay.dto.response.BaseResponse;
import com.astrapay.exception.NoteNotFoundException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(NoteNotFoundException.class)
    public ResponseEntity<BaseResponse<Object>> handleNoteNotFoundException(NoteNotFoundException ex) {
        log.warn("Handling NoteNotFoundException: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(BaseResponse.error(ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<BaseResponse<Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.warn("Handling MethodArgumentNotValidException");

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        log.warn("Validation errors: {}", errors);

        Map<String, Object> errorData = new HashMap<>();
        errorData.put("errors", errors);

        BaseResponse<Object> response = new BaseResponse<>("ERROR", "Validation failed", errorData);
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<BaseResponse<Object>> handleGenericException(Exception ex) {
        log.error("Handling generic exception: {}", ex.getMessage(), ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(BaseResponse.error("An unexpected error occurred"));
    }
}

================
File: src/main/java/com/astrapay/controller/NoteController.java
================
package com.astrapay.controller;

import com.astrapay.dto.request.CreateNoteRequestDto;
import com.astrapay.dto.response.BaseResponse;
import com.astrapay.dto.response.NoteDto;
import com.astrapay.service.NoteService;
import com.astrapay.util.ResponseHelper;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/notes")
@Api(value = "NoteController", tags = {"Simple Notes API"})
@Slf4j
@CrossOrigin(origins = "*")
public class NoteController {

    private final NoteService noteService;

    @Autowired
    public NoteController(NoteService noteService) {
        this.noteService = noteService;
    }

    @GetMapping
    @ApiOperation(value = "Get all notes", response = BaseResponse.class)
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Successfully retrieved list")
    })
    public ResponseEntity<BaseResponse<List<NoteDto>>> getAllNotes() {
        log.info("GET /notes called");
        List<NoteDto> notes = noteService.getAllNotes();
        return ResponseHelper.success("Notes retrieved successfully", notes, HttpStatus.OK);
    }

    @PostMapping
    @ApiOperation(value = "Create a new note", response = BaseResponse.class)
    @ApiResponses(value = {
            @ApiResponse(code = 201, message = "Successfully created note"),
            @ApiResponse(code = 400, message = "Invalid input, content cannot be empty")
    })
    public ResponseEntity<BaseResponse<NoteDto>> createNote(@Valid @RequestBody CreateNoteRequestDto requestDto) {
        log.info("POST /notes called with content: {}", requestDto.getContent());
        NoteDto createdNote = noteService.createNote(requestDto);
        return ResponseHelper.created("Note Successfully Added", createdNote);
    }

    @DeleteMapping("/{id}")
    @ApiOperation(value = "Delete a note by id")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Successfully deleted note"),
            @ApiResponse(code = 404, message = "Note not found")
    })
    public ResponseEntity<BaseResponse<String>> deleteNote(@PathVariable String id) {
        log.info("DELETE /notes/{} called", id);
        noteService.deleteNote(id);
        return ResponseHelper.success("Note deleted successfully", id, HttpStatus.OK);
    }
}

================
File: src/main/java/com/astrapay/dto/request/CreateNoteRequestDto.java
================
package com.astrapay.dto.request;

import lombok.Data;

import javax.validation.constraints.NotEmpty;

@Data
public class CreateNoteRequestDto {

    @NotEmpty(message = "Judul tidak boleh kosong")
    private String title;

    @NotEmpty(message = "Catatan tidak boleh kosong")
    private String content;
}

================
File: src/main/java/com/astrapay/dto/response/BaseResponse.java
================
package com.astrapay.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BaseResponse<T> {
    private String status;
    private String message;
    private T data;

    public static <T> BaseResponse<T> success(String message, T data) {
        return new BaseResponse<>("OK", message, data);
    }

    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>("OK", "Success", data);
    }

    public static <T> BaseResponse<T> error(String message) {
        return new BaseResponse<>("ERROR", message, null);
    }
}

================
File: src/main/java/com/astrapay/dto/response/NoteDto.java
================
package com.astrapay.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class NoteDto {
    private String id;
    private String title;
    private String content;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

================
File: src/main/java/com/astrapay/entity/Note.java
================
package com.astrapay.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Note {
    private String id;
    private String title;
    private String content;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

================
File: src/main/java/com/astrapay/exception/NoteNotFoundException.java
================
package com.astrapay.exception;

public class NoteNotFoundException extends RuntimeException {
    public NoteNotFoundException(String message) {
        super(message);
    }
}

================
File: src/main/java/com/astrapay/repository/NoteRepository.java
================
package com.astrapay.repository;

import com.astrapay.entity.Note;

import java.util.List;
import java.util.Optional;

public interface NoteRepository {
    Note save(Note note);
    List<Note> findAll();
    Optional<Note> findById(String id);
    void deleteById(String id);
}

================
File: src/main/java/com/astrapay/repository/NoteRepositoryImpl.java
================
package com.astrapay.repository;

import com.astrapay.entity.Note;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Repository
public class NoteRepositoryImpl implements NoteRepository {

    private final Map<String, Note> notes = new ConcurrentHashMap<>();

    @Override
    public Note save(Note note) {
        if (note.getId() == null) {
            note.setId(UUID.randomUUID().toString());
            note.setCreatedAt(LocalDateTime.now());
        }
        note.setUpdatedAt(LocalDateTime.now());
        notes.put(note.getId(), note);
        return note;
    }

    @Override
    public List<Note> findAll() {
        return notes.values().stream()
                .sorted((n1, n2) -> n2.getCreatedAt().compareTo(n1.getCreatedAt()))
                .collect(Collectors.toList());
    }

    @Override
    public Optional<Note> findById(String id) {
        return Optional.ofNullable(notes.get(id));
    }

    @Override
    public void deleteById(String id) {
        notes.remove(id);
    }
}

================
File: src/main/java/com/astrapay/service/NoteService.java
================
package com.astrapay.service;

import com.astrapay.dto.request.CreateNoteRequestDto;
import com.astrapay.dto.response.NoteDto;
import com.astrapay.entity.Note;
import com.astrapay.exception.NoteNotFoundException;
import com.astrapay.repository.NoteRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class NoteService {

    private final NoteRepository noteRepository;

    @Autowired
    public NoteService(NoteRepository noteRepository) {
        this.noteRepository = noteRepository;
    }

    public List<NoteDto> getAllNotes() {
        return noteRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public NoteDto createNote(CreateNoteRequestDto requestDto) {

        Note note = new Note();
        note.setContent(requestDto.getContent());

        Note savedNote = noteRepository.save(note);
        log.info("Note created: {}", savedNote.getId());
        return convertToDto(savedNote);
    }


    public void deleteNote(String id) {
        noteRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Note not found: {}", id);
                    return new NoteNotFoundException("Note not found with id: " + id);
                });

        noteRepository.deleteById(id);
        log.info("Note deleted: {}", id);
    }

    private NoteDto convertToDto(Note note) {
        return new NoteDto(
                note.getId(),
                note.getTitle(),
                note.getContent(),
                note.getCreatedAt(),
                note.getUpdatedAt()
        );
    }
}

================
File: src/main/java/com/astrapay/util/ResponseHelper.java
================
package com.astrapay.util;

import com.astrapay.dto.response.BaseResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

public class ResponseHelper {

    public static <T> ResponseEntity<BaseResponse<T>> success(String message, T data, HttpStatus status) {
        return new ResponseEntity<>(BaseResponse.success(message, data), status);
    }


    public static <T> ResponseEntity<BaseResponse<T>> created(String message, T data) {
        return new ResponseEntity<>(BaseResponse.success(message, data), HttpStatus.CREATED);
    }

    public static <T> ResponseEntity<BaseResponse<T>> noContent() {
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    public static ResponseEntity<BaseResponse<Object>> error(String message, HttpStatus status) {
        return new ResponseEntity<>(BaseResponse.error(message), status);
    }
}

================
File: src/main/java/com/astrapay/SimpleNotesApplication.java
================
package com.astrapay;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SimpleNotesApplication {
    public static void main(String[] args) {
        SpringApplication.run(SimpleNotesApplication.class, args);
    }
}

================
File: src/test/java/com/astrapay/controller/NoteControllerTest.java
================
package com.astrapay.controller;

import com.astrapay.dto.request.CreateNoteRequestDto;
import com.astrapay.dto.response.BaseResponse;
import com.astrapay.dto.response.NoteDto;
import com.astrapay.exception.NoteNotFoundException;
import com.astrapay.service.NoteService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.time.LocalDateTime;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(controllers = {NoteController.class, com.astrapay.controller.advice.GlobalExceptionHandler.class})
class NoteControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private NoteService noteService;

    @Test
    void testGetAllNotes() throws Exception {
        NoteDto noteDto = new NoteDto("1", "Test Title", "Test Note", LocalDateTime.now(), LocalDateTime.now());
        when(noteService.getAllNotes()).thenReturn(Collections.singletonList(noteDto));

        mockMvc.perform(get("/notes"))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.status").value("OK"))
                .andExpect(jsonPath("$.message").value("Notes retrieved successfully"))
                .andExpect(jsonPath("$.data[0].id").value("1"))
                .andExpect(jsonPath("$.data[0].content").value("Test Note"));
    }

    @Test
    void testCreateNote_Success() throws Exception {
        CreateNoteRequestDto requestDto = new CreateNoteRequestDto();
        requestDto.setTitle("New Title");
        requestDto.setContent("New Note");

        NoteDto responseDto = new NoteDto("new-id", "New Title", "New Note", LocalDateTime.now(), LocalDateTime.now());
        when(noteService.createNote(any(CreateNoteRequestDto.class))).thenReturn(responseDto);

        mockMvc.perform(post("/notes")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.status").value("OK"))
                .andExpect(jsonPath("$.message").value("Note Successfully Added"))
                .andExpect(jsonPath("$.data.id").value("new-id"))
                .andExpect(jsonPath("$.data.content").value("New Note"));
    }

    @Test
    void testCreateNote_ValidationFails() throws Exception {
        CreateNoteRequestDto requestDto = new CreateNoteRequestDto();
        requestDto.setContent("");
        mockMvc.perform(post("/notes")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value("ERROR"))
                .andExpect(jsonPath("$.message").value("Validation failed"))
                .andExpect(jsonPath("$.data.errors").exists());
    }


    @Test
    void testDeleteNote_Success() throws Exception {
        String noteIdToDelete = "1";
        doNothing().when(noteService).deleteNote(noteIdToDelete);

        mockMvc.perform(delete("/notes/" + noteIdToDelete))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.status").value("OK"))
                .andExpect(jsonPath("$.message").value("Note deleted successfully"))
                .andExpect(jsonPath("$.data").value(noteIdToDelete));
    }

    @Test
    void testDeleteNote_NotFound() throws Exception {
        String nonExistentId = "2";
        doThrow(new NoteNotFoundException("Note not found")).when(noteService).deleteNote(nonExistentId);

        mockMvc.perform(delete("/notes/" + nonExistentId))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.status").value("ERROR"))
                .andExpect(jsonPath("$.message").value("Note not found"));
    }
}

================
File: src/test/java/com/astrapay/service/NoteServiceTest.java
================
package com.astrapay.service;

import com.astrapay.dto.request.CreateNoteRequestDto;
import com.astrapay.dto.response.NoteDto;
import com.astrapay.entity.Note;
import com.astrapay.exception.NoteNotFoundException;
import com.astrapay.repository.NoteRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class NoteServiceTest {

    @Mock
    private NoteRepository noteRepository;

    @InjectMocks
    private NoteService noteService;

    private Note note;

    @BeforeEach
    void setUp() {
        note = new Note("1","Test Title", "Test Note", LocalDateTime.now(), LocalDateTime.now());
    }

    @Test
    void testGetAllNotes() {
        when(noteRepository.findAll()).thenReturn(Collections.singletonList(note));

        List<NoteDto> notes = noteService.getAllNotes();

        assertNotNull(notes);
        assertEquals(1, notes.size());
        assertEquals("Test Note", notes.get(0).getContent());
        verify(noteRepository, times(1)).findAll();
    }

    @Test
    void testCreateNote() {
        CreateNoteRequestDto requestDto = new CreateNoteRequestDto();
        requestDto.setContent("New Note");

        // Mock proses save
        when(noteRepository.save(any(Note.class))).thenAnswer(invocation -> {
            Note noteToSave = invocation.getArgument(0);
            noteToSave.setId("new-id");
            noteToSave.setCreatedAt(LocalDateTime.now());
            noteToSave.setUpdatedAt(LocalDateTime.now());
            return noteToSave;
        });

        NoteDto createdNote = noteService.createNote(requestDto);

        assertNotNull(createdNote);
        assertEquals("new-id", createdNote.getId());
        assertEquals("New Note", createdNote.getContent());
        verify(noteRepository, times(1)).save(any(Note.class));
    }

    @Test
    void testDeleteNote_Success() {
        when(noteRepository.findById("1")).thenReturn(Optional.of(note));
        doNothing().when(noteRepository).deleteById("1");

        assertDoesNotThrow(() -> noteService.deleteNote("1"));

        verify(noteRepository, times(1)).findById("1");
        verify(noteRepository, times(1)).deleteById("1");
    }

    @Test
    void testDeleteNote_NotFound() {
        when(noteRepository.findById("2")).thenReturn(Optional.empty());

        assertThrows(NoteNotFoundException.class, () -> noteService.deleteNote("2"));

        verify(noteRepository, times(1)).findById("2");
        verify(noteRepository, never()).deleteById(anyString());
    }
}

================
File: postman.json
================
{
  "info": {
    "_postman_id": "simple-notes-api",
    "name": "Simple Notes API",
    "description": "API documentation for Simple Notes application",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Notes",
      "item": [
        {
          "name": "Get All Notes",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/notes",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["notes"]
            },
            "description": "Retrieve all notes from the database"
          },
          "response": []
        },
        {
          "name": "Create Note",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"title\": \"Sample Note Title\",\n  \"content\": \"This is a sample note content\"\n}"
            },
            "url": {
              "raw": "http://localhost:8000/notes",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["notes"]
            },
            "description": "Create a new note with title and content"
          },
          "response": []
        },
        {
          "name": "Delete Note",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "http://localhost:8000/notes/{{noteId}}",
              "protocol": "http",
              "host": ["localhost"],
              "port": "8000",
              "path": ["notes", "{{noteId}}"]
            },
            "description": "Delete a specific note by ID. Returns a 200 OK status with the deleted note's ID in the response body."
          },
          "response": [
            {
              "name": "Successful Deletion",
              "originalRequest": {
                "method": "DELETE",
                "url": "http://localhost:8000/notes/1"
              },
              "status": "OK",
              "code": 200,
              "body": "{\n    \"status\": \"OK\",\n    \"message\": \"Note deleted successfully\",\n    \"data\": \"1\"\n}"
            }
          ]
        }
      ],
      "description": "Endpoints for managing notes"
    }
  ],
  "variable": [
    {
      "key": "noteId",
      "value": "1",
      "description": "ID of the note to delete"
    }
  ]
}

================
File: src/main/java/com/astrapay/configuration/ExampleConfig.java
================
package com.astrapay.configuration;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ExampleConfig {
    // You can use all of the standard DI annotations inside this class.
    // For example, you can use @Autowired to inject beans into this class.

}

================
File: src/main/resources/application.properties
================
server.port=8000

================
File: .gitignore
================
*#
*.iml
*.ipr
*.iws
*.jar
*.sw?
*~
.#*
.*.md.html
.DS_Store
.attach_pid*
.classpath
.factorypath
.gradle
.metadata
.project
.recommenders
.settings
.springBeans
.vscode
/code
MANIFEST.MF
_site/
activemq-data
bin
build
!/**/src/**/bin
!/**/src/**/build
build.log
dependency-reduced-pom.xml
dump.rdb
interpolated*.xml
lib/
manifest.yml
out
overridedb.*
target
.flattened-pom.xml
secrets.yml
.gradletasknamecache
.sts4-cache
.git-hooks/
node_modules

================
File: README.md
================
# Spring Boot Astrapay Base Project
Berikut adalah Base Project untuk aplikasi Spring Boot, yang sesuai dengan konvensi yang digunakan pada Astrapay.

#### Author Information:  
- Arthur Purnama
- Anton Rifco Susilo

## Package Structure
```
com
 +- astrapay
     +- [ServiceName]Application.java
     +- [service name]
         +- batch
             +- listener
                +- [Name]ReadListener.java
                +- [Name]ProcessListener.java
                +- [Name]WriteListener.java
                +- [Name]JobListener.java
             +-[Name]Batch.java
         +- client
             +- dto
                +- [Name]Dto.java
                +- [Name]RequestDto.java
             +- [Name]Client.java
         |
         +- configuration
         |   +- mapper
         |      +- [Name]Mapper
         |   +- [Name]Configuration.java
         |
         +- controller
             +- advice
                 +- [Name]Advice.java
             +- [Name]Controller.java
         |
         +- dto
             +- [Name]Dto.java
             +- [Name]RequestDto.java
         |
         +- exception
             +- [Name]Exception.java
         |
         +- entity
             +- [Name].java
         |
         +- enums
             +- [Name].java
         |
         +- repository
             +- [Name]Repository.java
         |
         +- security
             +- [Name]Security.java
         |
         +- service
             +- model
                +- [Name]Model.java
             +- [Name]Service.java
         |
         +- validator
             +- constraint
                 +- [Name].java
             +- [Name]Validator.java
```


## Resources Structure
```
resources
 +- application.properties
 +- application-prd.properties
 +- application-sit.properties
 +- application-uat.properties
 +- sql
    +- data.sql
    +- schema.sql
 +- Resource Bundle 'messages'
    +- messages.properties
    +- messages_id.properties
    +- messages_de.properties
```

### Configuration files

Configuration files untuk project spring AstraPay harus menggunakan key-value properties file. Setiap environment dipisah sebagai berikut

-   application.properties : Konfigurasi untuk local environment product developer
    
-   application-sit.properties: Konfigurasi untuk System Integration Test environment
    
-   application-uat.properties: Konfigurasi untuk User Acceptance Test environment
    
-   application-prd.properties: Konfigurasi untuk Production environment
    

### SQL files

Untuk file schema dan data yang digunakan dalam database terutama ketika testing di local environment menggunakan H2 in memory atau file database. File sql dapat diatur di configuration file, akan tetapi standard spring boot adalah `data.sql` untuk initialisasi data dan `schema.sql` untuk initialisasi schema.

### Resource Bundle

Internationalization files untuk berbagai macam messages yang ditampilkan di REST payload. Mengikuti aturan standard Spring untuk Internationalization resource bundle yaitu `messages.properties` untuk bahasa standard (umumnya english) dan `messages_[country code].properties` untuk terjemahan seperti misalnya `messages_id.properties` untuk indonesia

## Package

Nama package harus dimulai dengan **com.astrapay** lalu disusul dengan nama servicenya. Jika servicenya adalah payment maka nama paketnya menjadi **com.astrapay.payment**.

## Application

File main Application harus diletakkan di posisi folder root di atas kelas lain. Karena anotasi @SpringBootApplication memicu scanning semua komponen didalam paket dan sub-paketnya. Nama class adalah nama service nya. Jadi jika service nya bernama payment maka nama file nya **PaymentApplication**.

```
@SpringBootApplication
public class PaymentApplication {
  /**
   * Main app entry point
   */
  public static void main(String[] args) {
    SpringApplication.run(PaymentApplication.class, args);
  }
}
```

## Client

Folder ini adalah untuk class yang berkomunikasi dengan system atau service lain menggunakan Spring`RestTemplate`. Penamaan class diakhiri dengan `Client` dalam namanya. Contoh `AccountClient`.

RestTemplate object harus didefinisikan terlebih dahulu di Configuration class lalu di inject di Client Class. Jika aplikasi memiliki lebih dari 1 (satu) client, maka setiap bean configuration harus diberikan nama bean yang akan diinject menggunakan anotasi @Qualifier.

Contoh:
```
@Configuration
public class ProductClientConfiguration {

    @Value("${product.username}")
    private String productServiceUsername;

    @Value("${product.password}")
    private String productServicePassword;

    @Bean(name = "restTemplateForProductClient")
    public RestTemplate prepareRestTemplateForProductService() {

        BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(productServiceUsername, productServicePassword));

        RequestConfig.Builder requestBuilder = RequestConfig.custom();
        requestBuilder = requestBuilder.setConnectTimeout(1000);

        HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();
        httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);
        httpClientBuilder.setDefaultRequestConfig(requestBuilder.build());
        CloseableHttpClient httpClient = httpClientBuilder.build();

        HttpComponentsClientHttpRequestFactory rf = new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(rf);
    }
}

@Component
public class ProductClient {
  @Autowired
  @Qualifier("restTemplateForProductClient")
  RestTemplate restTemplateForProductClient;
  
  restTemplateForProductClient.......
}
```

## Configuration

Folder ini adalah untuk semua spring bean java based configuration class. Setiap nama class harus diakhiri dengan `Configuration.java` dibelakangnya, jadi misalkan security bisa menggunakan `SecurityConfiguration.java`.

Setiap Configuration class harus memiliki tujuan dan maksud penciptaan java beans yang jelas mengikuti prinsip [single responsibility](https://www.baeldung.com/java-single-responsibility-principle "https://www.baeldung.com/java-single-responsibility-principle") dan [high cohesion](https://madooei.github.io/cs421_sp20_homepage/cohesion/ "https://madooei.github.io/cs421_sp20_homepage/cohesion/").

Setiap class harus memiliki anotasi `@Configuration` dimana setiap method untuk menciptakan spring bean harus memiliki anotasi `@Bean`.

Contoh:

```
@Configuration
public class ExampleConfig {
    // You can use all of the standard DI annotations inside this class.
    @Autowired
    private SomeClass someClass;

    // This is the definition of a Bean of type AnotherClass.
    // As shown, method arguments are another way to pass in dependencies.
    @Bean
    public AnotherClass anotherClass(SomeClass someClass) {
        return new AnotherClass(someClass);
    }

    // Other definitions...
}
```

## Controller

Folder ini adalah untuk Spring MVC Controller. Karena AstraPay menggunakan Java dan Spring spesifik untuk implementasi backend RESTful web services, maka controller yang digunakan hanya REST Controller.

Setiap nama class controller harus diakhiri dengan `Controller.java` dibelakangnya, jadi misalkan payment menjadi`PaymentController.java`.

Contoh sebuah REST Controller sebagai berikut

```
@RestController
@Api(value = "Account controller")
public class AccountController {
  @Autowired
  private AccountService accountService;

  @GetMapping("/accounts")
  @ApiOperation(value = "Get latest balance")
  @ApiResponses(
    value = {
      @ApiResponse(code = 200, message = "OK", response = AccountDto.class)
    }
  )
  public Page<AccountDto> getAllAccountsByUserId(
    @Validated(AccountDtoGroup.class) AccountDto accountDto,
    Pageable pageable
  ) {
    return accountService.getAllAccountsByUserId(accountDto.getUserId(), pageable);
  }

}
```

Aturan lebih lengkap tentang implementasi REST Controller dapat dilihat pada dokumen [Spring RESTful Web Services](https://astrapay.atlassian.net/wiki/spaces/PD/pages/1565098966)

### Advice

Folder ini bertujuan untuk menyimpan Spring Global Rest Exception dan Binder handling. Setiap class memiliki nama yang diakhiri dengan `Advice`. Setiap class harus dideklarasikan dengan anotasi `@RestControllerAdvice`. Setiap exception yang ingin ditangkap dan di handle harus di deklarasikan disini menggunakan `@ExceptionHandler` dan di deklarasikan juga response statusnya menggunakan `@ResponseStatus`.

Contoh:

```
@ControllerAdvice
class GlobalControllerExceptionHandler {
    @ResponseStatus(HttpStatus.CONFLICT)  // 409
    @ExceptionHandler(DataIntegrityViolationException.class)
    public void handleConflict() {
        // Nothing to do
    }
}
```

## Data Transfer Object - Pada Controller

Data Transfer Object di AstraPay adalah Data Object yang digunakan ketika data atau informasi **meninggalkan** aplikasi/service/system atau **datang** dari aplikasi/service/system lain.

Data Transfer Object jenis ini digunakan hanya di Controller.

DTO ini merefleksikan endpoint parameter yang kita tuliskan di dokumentasi API. Dengan kata lain DTO pada Contoller adalah kontrak endpoint API kita dengan service lain yang ingin menggunakan endpoint kita.

Untuk aturannya, setiap nama dto harus diakhiri dengan `Dto.java` dibelakangnya, jadi misalkan payment bisa menggunakan `PaymentDto.java`.

Buat DTO untuk setiap request endpoint dan DTO lain secara terpisah untuk setiap response. Menggunakan DTO terpisah memungkinkan kita untuk mengoptimalkan transfer data. Hal ini juga dapat membantu untuk membatasi akses ke property yang tidak ingin diekspos. Dengan cara seperti ini, data yang bisa diekspose dapat didefinisikan dengan tepat dan dapat dikontrol dengan mudah.

Jika elemen atau property umum dan sama teridentifikasi pada beberapa endpoints, maka **cukup buat satu DTO yang digunakan di beberapa endpoints tersebut baik untuk request ataupun response nya**.

```
public class ProductRequestDto {
    private String name;
    private Double price;
}

public class ProductDto {
    private Long id;
    private String name;
    private Double price;
}
```

Aturan lebih lengkap tentang implementasi Data Transfer Object dapat dilihat pada dokumen [Spring RESTful Web Services](https://astrapay.atlassian.net/wiki/spaces/PD/pages/1565098966)

## Exception

Folder ini adalah untuk custom Exception. Aturan dan pertimbangan berikut harus diikuti jika ingin membuat custom exception.

### Harus memiliki manfaat dan tujuan yang jelas

Setiap custom exception harus memiliki manfaat dan tujuan yang jelas. Custom exception harus memberikan informasi atau fungsionalitas tambahan yang bukan bagian dari standard exception atau exception lain yang disediakan oleh framework.

Jika tidak ada manfaat dan tujuan nya, maka silahkan gunakan exception yang sudah disediakan oleh JDK atau framework yang sudah umum diketahui oleh semua product developer.

### Naming convention

Setiap nama exception harus diakhiri menggunakan `Exception` dibelakangnya. Contohnya `MyCustomException`.

Tujuan dari exception harus menentukan apakah custom exception ini harus berupa [checked atau unchecked exception](https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java "https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java").

Gunakan _checked exception_ untuk semua event luar biasa yang tidak dapat diantisipasi dan **harus ditangani dalam aplikasi**. _Checked exception_ harus menurunkan kelas Exception

Contoh :

```
public class MyCustomCheckedException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}
```

Gunakan unchecked exception untuk semua internal error yang tidak dapat diantisipasi dan dimana aplikasi **tidak dapat atau tidak boleh recover**. Unchecked exception harus menurunkan kelas RuntimeException

Contoh:

```
public class MyCustomUncheckedException extends RuntimeException {
    public MyCustomException(String message) {
        super(message);
    }
}
```

### Berikan Javadoc comments

Javadoc harus menjelaskan tujuan dan maksud dari exception tersebut dan dalam situasi apa exception tersebut harus muncul. Tujuannya adalam membantu product developer lain untuk memahami code kalian dengan lebih baik dan menghindari kesalahan yang tidak perlu.

### Definisikan Constructor yang menentukan existensinya

Karena custom exception harus memiliki manfaat dan tujuan yang jelas, maka harus ada juga constructor yang dapat menyatakan atau menentukan existensi dari custom exception tersebut.

Contoh:

```
public class MyCustomCheckedException extends Exception {
    ...
    public MyCustomException(String message, Throwable cause, ErrorCode code) {
		super(message, cause);
		this.code = code;
	}
	...
}
```

## Entity

Pembuatan class model cukup menggunakan nama entitas yang dibutuhkan. Sebagai contoh kita ingin membuat model payment. Maka akan menjadi `Payments.class` dengan contoh sebagai berikut :

```
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class Payment {

    @Id
    @Column(name = "payment_id")
    private String paymentId;

    @ManyToOne(targetEntity = Transaction.class)
    @JoinColumn(name = "transaction_id", insertable = false, updatable = false)
    private Transaction transactionId;

    @Column(name = "is_active")
    private Boolean isActive;

    @Column(name = "created_at", updatable = false, columnDefinition = "TIMESTAMP")
    private LocalDateTime createdAt;

    @Column(name = "updated_at", columnDefinition = "TIMESTAMP")
    private LocalDateTime updatedAt;

    @Column(name = "created_by", updatable = false)
    private String createdBy;

    @Column(name = "updated_by")
    private String updatedBy;

    @PrePersist
    protected void prePersist() {
        this.brandId = String.valueOf(UUID.randomUUID());
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

Pada model diharapkan penggunaan annotation di perluas, seperti penggunakan column name, penggunaan lombok project.

## Enums

Enum bukan Constants. Penggunaan enum di Java memberikan banyak kelebihan dalam membuat implementasi yang lebih baik. Jika sebuah constant memiliki relasi logik terhadap sebuah class, maka harus di definisikan dalam class tersebut. Hanya jika satu set constant teridentifikasi sebagai sebuah enumerasi, maka harus didefinisikan sebagai enum.

Penggunaan enum men support Type Safe dan memaksa pembatasan terhadap value yang bisa digunakan. Penamaan enum tidak menggunakan prefix dan suffix.

Contoh:
```
`//OK String playerType =  Constants.MALE; // Compile-time error - incompatible types! PlayerType playerType =  Gender.MALE;`
```
Enum juga mendukung polymorphic design principle.

Contoh:

```
@Test
public void paper_beats_rock() {
	assertThat(PAPER.beats(ROCK)).isTrue();
	assertThat(ROCK.beats(PAPER)).isFalse();
}
@Test
public void scissors_beats_paper() {
	assertThat(SCISSORS.beats(PAPER)).isTrue();
	assertThat(PAPER.beats(SCISSORS)).isFalse();
}
@Test
public void rock_beats_scissors() {
	assertThat(ROCK.beats(SCISSORS)).isTrue();
	assertThat(SCISSORS.beats(ROCK)).isFalse();
}

public enum Gesture {
	ROCK() {
		// Enums are polymorphic, that's really handy!
		@Override
		public boolean beats(Gesture other) {
			return other == SCISSORS;
		}
	},
	PAPER, SCISSORS;

	// we can implement with the integer representation
	public boolean beats(Gesture other) {
		return ordinal() - other.ordinal() == 1;
	}
}
```

## Repository

Setiap nama repository harus menggunakan `Repository.java` dibelakangnya, misalkan kita ingin membuat repository untuk payment, maka buatlah menjadi `PaymentRepositoy.java`. Pada repository diharapkan tidak menggunakan native query.

Berikut contohnya :
```
@Query(value = "select customer from AstrapayCustomer customer") 
LinkedList<AstrapayCustomer>  getCustomer();
```

## Security

Setiap nama security harus diakhir dengan `Security.java` dibelakangnya, misalkan kita ingin membuat security untuk Api, maka menjadi `ApiSecurity.java`.

Security berfungsi untuk menangani seluruh keamanan pada Rest Api sebelum data masuk pada Controller. Beberapa fungsionalitas yang akan masuk pada security antara lain [CSRF](https://owasp.org/www-community/attacks/csrf#:~:text=Cross%2DSite%20Request%20Forgery%20(CSRF,which%20they're%20currently%20authenticated. "https://owasp.org/www-community/attacks/csrf#:~:text=Cross%2DSite%20Request%20Forgery%20(CSRF,which%20they're%20currently%20authenticated.") (Cross Site Request Forgery), encryption, decryption.

Contoh:
```
@Configuration
@EnableWebSecurity
public class ApiSecurity extends WebSecurityConfigurerAdapter {
  
   @Override
   protected void configure(HttpSecurity http) throws Exception {
    http
      .csrf()
      .disable()
      .authorizeRequests()
      // Enabled swagger end points
      .antMatchers(
        "/v2/api-docs",
        "/configuration/**",
        "/swagger*/**",
        "/webjars/**"
      )
      .permitAll()
      ;
  }
}
```

## Service

Setiap nama service harus diakhiri dengan `Service.java` dibelakangnya, misalkan kita ingin membuat service untuk payment, maka menjadi `PaymentService.java`.

Ketika sebuah service hanya memiliki **1(Satu)** Implementasi konkrit maka **tidak perlu membuat interface**. Membuat interface hanya untuk satu implementasi konkrit seperti `PaymentServiceImpl` adalah sebuah anti-pattern.

Berikut alasannya:

1.  Jika kalian tiba tiba harus membuat implementasi lain nya (itu point nya membuat interface), mau dinamain apa implementasinya? `PaymentServiceImpl2` ?
    
2.  Setiap kali kita membuat service, kita punya 2 artefak yang hanya meningkatkan kompleksitas implementasi kita.
    
3.  Membuat dokumentasi Javadocs menjadi redundant
    
4.  Navigasi menggunakan IDE menjadi tidak mudah.
    
5.  Menamakan class dengan Suffix Impl seperti menyatakan “saya tidak tahu lagi harus namain apa”, dan ini adalah tanda-tanda code smell
    
6.  Jika alasannya adalah mocking object ketika unit testing, mockito juga sudah lama bisa [mocking concrete object](https://javadoc.io/static/org.mockito/mockito-core/3.10.0/org/mockito/Mockito.html#stubbing "https://javadoc.io/static/org.mockito/mockito-core/3.10.0/org/mockito/Mockito.html#stubbing")
    

## Validator

Folder ini bertujuan untuk menyimpan semua bean validation sesuai spesifikasi [JSR-380 Bean Validation 2.0](https://beanvalidation.org/2.0/spec/ "https://beanvalidation.org/2.0/spec/"). Setiap class memiliki nama yang diakhiri dengan `Validator`. Setiap class meng implements `ConstraintValidator`.

Contoh:
```
public class CheckSumValidator implements ConstraintValidator<CheckSum, QrisPayload> {

    @Override
    public boolean isValid(QrisPayload value, ConstraintValidatorContext context) {
        String crcCheckSum = generateChecksum(value.getPayload().substring(0, value.getPayload().length()-4));
        return crcCheckSum.equals(value.getQrisRoot().get(63).getValue());
    }

    private String generateChecksum(String payload) {
        int checksum = 0xffff;
        int polynomial = 0x1021;
        byte[] data = payload.getBytes(StandardCharsets.UTF_8);
        for (byte b : data) {
            for (int i = 0; i < 8; i++) {
                boolean bit = ((b >> (7 - i) & 1) == 1);
                boolean c15 = ((checksum >> 15 & 1) == 1);
                checksum <<= 1;
                if (c15 ^ bit) {
                    checksum ^= polynomial;
                }
            }
        }
        checksum &= 0xffff;
        return String.format("%04X", checksum);
    }
}
```

### Constraint

Folder ini adalah untuk mengimplementasi custom Annotation untuk bean validation. Penamaan class tidak memiliki prefix dan suffix.

Contoh:

```
@Documented
@Constraint(validatedBy = {CheckSumValidator.class})
@Target({TYPE})
@Retention(RUNTIME)
public @interface CheckSum {

    /**
     *
     * @return String
     */
    String message() default "Checksum wajib dihitung sesuai dengan [ISO/IEC 13239]";

    /**
     *
     * @return class
     */
    Class<?>[] groups() default {};

    /**
     *
     * @return class
     */
    Class<? extends Payload>[] payload() default {};
}
```

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.astrapay</groupId>
    <artifactId>simple-notes</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>3.0.0</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>





================================================================
End of Codebase
================================================================
